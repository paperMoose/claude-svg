{"version":3,"file":"ext-connector.js","sources":["../../../../src/editor/extensions/ext-connector/ext-connector.js","../../../../src/editor/extensions/ext-connector/locale/en.js","../../../../src/editor/extensions/ext-connector/locale/fr.js","../../../../src/editor/extensions/ext-connector/locale/zh-CN.js"],"sourcesContent":["/**\n * @file ext-connector.js\n *\n * @license MIT\n *\n * @copyright 2010 Alexis Deveria\n * @copyright 2023 Optimistik SAS\n *\n */\n\nconst name = 'connector'\n\nconst loadExtensionTranslation = async function (svgEditor) {\n  let translationModule\n  const lang = svgEditor.configObj.pref('lang')\n  try {\n    translationModule = await import(`./locale/${lang}.js`)\n  } catch (_error) {\n    // eslint-disable-next-line no-console\n    console.warn(`Missing translation (${lang}) for ${name} - using 'en'`)\n    translationModule = await import('./locale/en.js')\n  }\n  svgEditor.i18next.addResourceBundle(lang, name, translationModule.default)\n}\n\nexport default {\n  name,\n  async init (S) {\n    const svgEditor = this\n    const { svgCanvas } = svgEditor\n    const { getElement, $id, $click, addSVGElementsFromJson } = svgCanvas\n    const { svgroot, selectorManager } = S\n    const seNs = svgCanvas.getEditorNS()\n    await loadExtensionTranslation(svgEditor)\n\n    let startX\n    let startY\n    let curLine\n    let startElem\n    let endElem\n\n    let started = false\n    let connections = []\n\n    // Save the original groupSelectedElements method\n    const originalGroupSelectedElements = svgCanvas.groupSelectedElements\n\n    // Override the original groupSelectedElements to exclude connectors\n    svgCanvas.groupSelectedElements = function (...args) {\n      // Remove connectors from selection\n      svgCanvas.removeFromSelection(document.querySelectorAll('[id^=\"conn_\"]'))\n\n      // Call the original method\n      return originalGroupSelectedElements.apply(this, args)\n    }\n\n    // Save the original moveSelectedElements method\n    const originalMoveSelectedElements = svgCanvas.moveSelectedElements\n\n    // Override the original moveSelectedElements to handle connectors\n    svgCanvas.moveSelectedElements = function (...args) {\n      // Call the original method and store its result\n      const cmd = originalMoveSelectedElements.apply(this, args)\n\n      // Update connectors\n      updateConnectors(svgCanvas.getSelectedElements())\n\n      // Return the result of the original method\n      return cmd\n    }\n\n    /**\n     * getBBintersect\n     * @param {Float} x\n     * @param {Float} y\n     * @param {module:utilities.BBoxObject} bb\n     * @param {Float} offset\n     * @returns {module:math.XYObject}\n     */\n    const getBBintersect = (x, y, bb, offset) => {\n      // Adjust bounding box if offset is provided\n      if (offset) {\n        bb = { ...bb } // Create a shallow copy\n        bb.width += offset\n        bb.height += offset\n        bb.x -= offset / 2\n        bb.y -= offset / 2\n      }\n\n      // Calculate center of bounding box\n      const midX = bb.x + bb.width / 2\n      const midY = bb.y + bb.height / 2\n\n      // Calculate lengths from (x, y) to center\n      const lenX = x - midX\n      const lenY = y - midY\n\n      // Calculate slope of line from (x, y) to center\n      const slope = Math.abs(lenY / lenX)\n\n      // Calculate ratio to find intersection point\n      let ratio\n      if (slope < bb.height / bb.width) {\n        ratio = bb.width / 2 / Math.abs(lenX)\n      } else {\n        ratio = lenY ? bb.height / 2 / Math.abs(lenY) : 0\n      }\n\n      // Calculate intersection point\n      return {\n        x: midX + lenX * ratio,\n        y: midY + lenY * ratio\n      }\n    }\n\n    /**\n     * getOffset\n     * @param {\"start\"|\"end\"} side - The side of the line (\"start\" or \"end\") where the marker may be present.\n     * @param {Element} line - The line element to check for a marker.\n     * @returns {Float} - Returns the calculated offset if a marker is present, otherwise returns 0.\n     */\n    const getOffset = (side, line) => {\n      // Check for marker attribute on the given side (\"marker-start\" or \"marker-end\")\n      const hasMarker = line.getAttribute('marker-' + side)\n\n      // Calculate size based on stroke-width, multiplied by a constant factor (here, 5)\n      // TODO: This factor should ideally be based on the actual size of the marker.\n      const size = line.getAttribute('stroke-width') * 5\n\n      // Return calculated size if marker is present, otherwise return 0.\n      return hasMarker ? size : 0\n    }\n\n    /**\n     * showPanel\n     * @param {boolean} on - Determines whether to show or hide the elements.\n     * @returns {void}\n     */\n    const showPanel = on => {\n      // Find the 'connector_rules' or create it if it doesn't exist.\n      let connRules = $id('connector_rules')\n      if (!connRules) {\n        connRules = document.createElement('style')\n        connRules.setAttribute('id', 'connector_rules')\n        document.getElementsByTagName('head')[0].appendChild(connRules)\n      }\n\n      // Update the content of <style> element to either hide or show certain elements.\n      connRules.textContent = !on\n        ? ''\n        : '#tool_clone, #tool_topath, #tool_angle, #xy_panel { display: none !important; }'\n\n      // Update the display property of the <style> element itself based on the 'on' value.\n      if ($id('connector_rules')) {\n        $id('connector_rules').style.display = on ? 'block' : 'none'\n      }\n    }\n\n    /**\n     * setPoint\n     * @param {Element} elem - The SVG element.\n     * @param {Integer|\"end\"} pos - The position index or \"end\".\n     * @param {Float} x - The x-coordinate.\n     * @param {Float} y - The y-coordinate.\n     * @param {boolean} [setMid] - Whether to set the midpoint.\n     * @returns {void}\n     */\n    const setPoint = (elem, pos, x, y, setMid) => {\n      // Create a new SVG point\n      const pts = elem.points\n      const pt = svgroot.createSVGPoint()\n      pt.x = x\n      pt.y = y\n\n      // If position is \"end\", set it to the last index\n      if (pos === 'end') {\n        pos = pts.numberOfItems - 1\n      }\n\n      // Try replacing the point at the specified position\n      pts.replaceItem(pt, pos)\n\n      // Optionally, set the midpoint\n      if (setMid) {\n        const ptStart = pts.getItem(0)\n        const ptEnd = pts.getItem(pts.numberOfItems - 1)\n        setPoint(elem, 1, (ptEnd.x + ptStart.x) / 2, (ptEnd.y + ptStart.y) / 2)\n      }\n    }\n\n    /**\n     * @param {Float} diffX\n     * @param {Float} diffY\n     * @returns {void}\n     */\n    const updatePoints = (line, conn, bb, altBB, pre, altPre) => {\n      const srcX = altBB.x + altBB.width / 2\n      const srcY = altBB.y + altBB.height / 2\n\n      const pt = getBBintersect(srcX, srcY, bb, getOffset(pre, line))\n      setPoint(line, conn.is_start ? 0 : 'end', pt.x, pt.y, true)\n\n      const pt2 = getBBintersect(pt.x, pt.y, altBB, getOffset(altPre, line))\n      setPoint(line, conn.is_start ? 'end' : 0, pt2.x, pt2.y, true)\n    }\n\n    const updateLine = (diffX, diffY) => {\n      const dataStorage = svgCanvas.getDataStorage()\n\n      for (const conn of connections) {\n        const {\n          connector: line,\n          is_start: isStart,\n          start_x: startX,\n          start_y: startY\n        } = conn\n\n        const pre = isStart ? 'start' : 'end'\n        const altPre = isStart ? 'end' : 'start'\n\n        // Update bbox for this element\n        const bb = { ...dataStorage.get(line, `${pre}_bb`) }\n        bb.x = startX + diffX\n        bb.y = startY + diffY\n\n        dataStorage.put(line, `${pre}_bb`, bb)\n\n        // Get center point of connected element\n        const altBB = dataStorage.get(line, `${altPre}_bb`)\n\n        updatePoints(line, conn, bb, altBB, pre, altPre)\n      }\n    }\n\n    // Finds connectors associated with selected elements\n    const findConnectors = (elems = []) => {\n      // Fetch data storage object from svgCanvas\n      const dataStorage = svgCanvas.getDataStorage()\n\n      // Query all connector elements (id startss with conn_)\n      const connectors = document.querySelectorAll('[id^=\"conn_\"]')\n      // Reset connections array\n      connections = []\n\n      // Loop through each connector\n      for (const connector of connectors) {\n        let addThis = false // Flag to indicate whether to add this connector\n        const parts = [] // To hold the starting and ending elements connected by the connector\n\n        // Loop through the connector ends (\"start\" and \"end\")\n        for (const [i, pos] of ['start', 'end'].entries()) {\n          // Fetch connected element and its bounding box\n          let part = dataStorage.get(connector, `c_${pos}`)\n\n          // If part is null or undefined, fetch it and store it\n          if (!part) {\n            part = document.getElementById(\n              connector.attributes['se:connector'].value.split(' ')[i]\n            )\n            dataStorage.put(connector, `c_${pos}`, part.id)\n            dataStorage.put(\n              connector,\n              `${pos}_bb`,\n              svgCanvas.getStrokedBBox([part])\n            )\n          } else {\n            // If part is already stored, fetch it by ID\n            part = document.getElementById(part)\n          }\n\n          // Add the part to the parts array\n          parts.push(part)\n        }\n\n        // Loop through the starting and ending elements connected by the connector\n        for (let i = 0; i < 2; i++) {\n          const cElem = parts[i]\n          const parents = svgCanvas.getParents(cElem?.parentNode)\n\n          // Check if the element is part of a selected group\n          for (const el of parents) {\n            if (elems.includes(el)) {\n              addThis = true\n              break\n            }\n          }\n\n          // If element is missing or parent is null, remove the connector\n          if (!cElem || !cElem.parentNode) {\n            connector.remove()\n            continue\n          }\n\n          // If element is in the selection or part of a selected group\n          if (elems.includes(cElem) || addThis) {\n            const bb = svgCanvas.getStrokedBBox([cElem])\n\n            // Add connection information to the connections array\n            connections.push({\n              elem: cElem,\n              connector,\n              is_start: i === 0,\n              start_x: bb.x,\n              start_y: bb.y\n            })\n          }\n        }\n      }\n    }\n\n    /**\n     * Updates the connectors based on selected elements.\n     * @param {Element[]} [elems] - Optional array of selected elements.\n     * @returns {void}\n     */\n    const updateConnectors = elems => {\n      const dataStorage = svgCanvas.getDataStorage()\n\n      // Find connectors associated with selected elements\n      findConnectors(elems)\n\n      if (connections.length) {\n        // Iterate through each connection to update its state\n        for (const conn of connections) {\n          const {\n            elem,\n            connector: line,\n            is_start: isStart,\n            start_x: startX,\n            start_y: startY\n          } = conn\n\n          // Determine whether the connection starts or ends with this element\n          const pre = isStart ? 'start' : 'end'\n\n          // Update the bounding box for this element\n          const bb = svgCanvas.getStrokedBBox([elem])\n          bb.x = startX\n          bb.y = startY\n          dataStorage.put(line, `${pre}_bb`, bb)\n\n          // Determine the opposite end ('start' or 'end') of the connection\n          const altPre = isStart ? 'end' : 'start'\n\n          // Retrieve the bounding box for the connected element at the opposite end\n          const bb2 = dataStorage.get(line, `${altPre}_bb`)\n\n          // Calculate the center point of the connected element\n          const srcX = bb2?.x + bb2?.width / 2\n          const srcY = bb2?.y + bb2?.height / 2\n\n          // Update the point of the element being moved\n          const pt = getBBintersect(srcX, srcY, bb, getOffset(pre, line))\n          setPoint(line, isStart ? 0 : 'end', pt.x, pt.y, true)\n\n          // Update the point of the connected element at the opposite end\n          const pt2 = getBBintersect(\n            pt.x,\n            pt.y,\n            dataStorage.get(line, `${altPre}_bb`),\n            getOffset(altPre, line)\n          )\n          setPoint(line, isStart ? 'end' : 0, pt2.x, pt2.y, true)\n        }\n      }\n    }\n\n    /**\n     * Do on reset.\n     * @returns {void}\n     */\n    const reset = () => {\n      const dataStorage = svgCanvas.getDataStorage()\n      // Make sure all connectors have data set\n      const svgContent = svgCanvas.getSvgContent()\n      const elements = svgContent.querySelectorAll('*')\n      elements.forEach(element => {\n        const conn = element.getAttributeNS(seNs, 'connector')\n        if (conn) {\n          const connData = conn.split(' ')\n          const sbb = svgCanvas.getStrokedBBox([getElement(connData[0])])\n          const ebb = svgCanvas.getStrokedBBox([getElement(connData[1])])\n          dataStorage.put(element, 'c_start', connData[0])\n          dataStorage.put(element, 'c_end', connData[1])\n          dataStorage.put(element, 'start_bb', sbb)\n          dataStorage.put(element, 'end_bb', ebb)\n          svgCanvas.getEditorNS(true)\n        }\n      })\n    }\n\n    reset()\n\n    return {\n      name: svgEditor.i18next.t(`${name}:name`),\n      callback () {\n        // Add the button and its handler(s)\n        const buttonTemplate = document.createElement('template')\n        const title = `${name}:buttons.0.title`\n        buttonTemplate.innerHTML = `\n         <se-button id=\"tool_connect\" title=\"${title}\" src=\"conn.svg\"></se-button>\n         `\n        $id('tools_left').append(buttonTemplate.content.cloneNode(true))\n        $click($id('tool_connect'), () => {\n          if (this.leftPanel.updateLeftPanel('tool_connect')) {\n            svgCanvas.setMode('connector')\n          }\n        })\n      },\n      mouseDown (opts) {\n        // Retrieve necessary data from the SVG canvas and the event object\n        const dataStorage = svgCanvas.getDataStorage()\n        const svgContent = svgCanvas.getSvgContent()\n        const { event: e, start_x: startX, start_y: startY } = opts\n        const mode = svgCanvas.getMode()\n        const {\n          curConfig: { initStroke }\n        } = svgEditor.configObj\n\n        if (mode === 'connector') {\n          // Return if the line is already started\n          if (started) return undefined\n\n          const mouseTarget = e.target\n          const parents = svgCanvas.getParents(mouseTarget.parentNode)\n\n          // Check if the target is a child of the main SVG content\n          if (parents.includes(svgContent)) {\n            // Identify the connectable element, considering foreignObject elements\n            const fo = svgCanvas.getClosest(\n              mouseTarget.parentNode,\n              'foreignObject'\n            )\n            startElem = fo || mouseTarget\n\n            // Retrieve the bounding box and calculate the center of the start element\n            const bb = svgCanvas.getStrokedBBox([startElem])\n            const x = bb.x + bb.width / 2\n            const y = bb.y + bb.height / 2\n\n            // Set the flag to indicate the line has started\n            started = true\n\n            // Create a new polyline element\n            curLine = addSVGElementsFromJson({\n              element: 'polyline',\n              attr: {\n                id: 'conn_' + svgCanvas.getNextId(),\n                points: `${x},${y} ${x},${y} ${startX},${startY}`,\n                stroke: `#${initStroke.color}`,\n                'stroke-width':\n                  !startElem.stroke_width || startElem.stroke_width === 0\n                    ? initStroke.width\n                    : startElem.stroke_width,\n                fill: 'none',\n                opacity: initStroke.opacity,\n                style: 'pointer-events:none'\n              }\n            })\n\n            // Store the bounding box of the start element\n            dataStorage.put(curLine, 'start_bb', bb)\n          }\n\n          return {\n            started: true\n          }\n        }\n\n        if (mode === 'select') {\n          // Find connectors if the mode is 'select'\n          findConnectors(opts.selectedElements)\n        }\n\n        return undefined\n      },\n      mouseMove (opts) {\n        // Exit early if there are no connectors\n        if (connections.length === 0) return\n\n        const dataStorage = svgCanvas.getDataStorage()\n        const zoom = svgCanvas.getZoom()\n        // const e = opts.event;\n        const x = opts.mouse_x / zoom\n        const y = opts.mouse_y / zoom\n        /** @todo  We have a concern if startX or startY are undefined */\n        if (!startX || !startY) return\n\n        const diffX = x - startX\n        const diffY = y - startY\n\n        const mode = svgCanvas.getMode()\n        if (mode === 'connector' && started) {\n          // const sw = curLine.getAttribute('stroke-width') * 3;\n          // Set start point (adjusts based on bb)\n          const pt = getBBintersect(\n            x,\n            y,\n            dataStorage.get(curLine, 'start_bb'),\n            getOffset('start', curLine)\n          )\n          startX = pt.x\n          startY = pt.y\n\n          setPoint(curLine, 0, pt.x, pt.y, true)\n\n          // Set end point\n          setPoint(curLine, 'end', x, y, true)\n        } else if (mode === 'select') {\n          for (const elem of svgCanvas.getSelectedElements()) {\n            if (elem && dataStorage.has(elem, 'c_start')) {\n              svgCanvas.removeFromSelection([elem])\n              elem.transform.baseVal.clear()\n            }\n          }\n          if (connections.length) {\n            updateLine(diffX, diffY)\n          }\n        }\n      },\n      mouseUp (opts) {\n        // Get necessary data and initial setups\n        const dataStorage = svgCanvas.getDataStorage()\n        const svgContent = svgCanvas.getSvgContent()\n        const { event: e } = opts\n        let mouseTarget = e.target\n\n        // Early exit if not in connector mode\n        if (svgCanvas.getMode() !== 'connector') return undefined\n\n        // Check for a foreignObject parent and update mouseTarget if found\n        const fo = svgCanvas.getClosest(mouseTarget.parentNode, 'foreignObject')\n        if (fo) mouseTarget = fo\n\n        // Check if the target is a child of the main SVG content\n        const parents = svgCanvas.getParents(mouseTarget.parentNode)\n        const isInSvgContent = parents.includes(svgContent)\n\n        if (mouseTarget === startElem) {\n          // Case: Started drawing line via click\n          started = true\n          return {\n            keep: true,\n            element: null,\n            started\n          }\n        }\n\n        if (!isInSvgContent) {\n          // Case: Invalid target element; remove the line\n          curLine?.remove()\n          started = false\n          return {\n            keep: false,\n            element: null,\n            started\n          }\n        }\n\n        // Valid target element for the end of the line\n        endElem = mouseTarget\n\n        const startId = startElem?.id || ''\n        const endId = endElem?.id || ''\n        const connStr = `${startId} ${endId}`\n        const altStr = `${endId} ${startId}`\n\n        // Prevent duplicate connectors\n        const dupe = Array.from(\n          document.querySelectorAll('[id^=\"conn_\"]')\n        ).filter(\n          conn =>\n            conn.getAttributeNS(seNs, 'connector') === connStr ||\n            conn.getAttributeNS(seNs, 'connector') === altStr\n        )\n\n        if (dupe.length) {\n          curLine.remove()\n          return {\n            keep: false,\n            element: null,\n            started: false\n          }\n        }\n\n        // Update the end point of the connector\n        const bb = svgCanvas.getStrokedBBox([endElem])\n        const pt = getBBintersect(\n          startX,\n          startY,\n          bb,\n          getOffset('start', curLine)\n        )\n        setPoint(curLine, 'end', pt.x, pt.y, true)\n\n        // Save metadata to the connector\n        dataStorage.put(curLine, 'c_start', startId)\n        dataStorage.put(curLine, 'c_end', endId)\n        dataStorage.put(curLine, 'end_bb', bb)\n        curLine.setAttributeNS(seNs, 'se:connector', connStr)\n        curLine.setAttribute('opacity', 1)\n\n        // Finalize the connector\n        svgCanvas.addToSelection([curLine])\n        svgCanvas.moveToBottomSelectedElement()\n        selectorManager.requestSelector(curLine).showGrips(false)\n\n        started = false\n        return {\n          keep: true,\n          element: curLine,\n          started\n        }\n      },\n      selectedChanged (opts) {\n        // Get necessary data storage and SVG content\n        const dataStorage = svgCanvas.getDataStorage()\n        const svgContent = svgCanvas.getSvgContent()\n\n        // Exit early if there are no connectors\n        if (!svgContent.querySelectorAll('[id^=\"conn_\"]').length) return\n\n        // If the current mode is 'connector', switch to 'select'\n        if (svgCanvas.getMode() === 'connector') {\n          svgCanvas.setMode('select')\n        }\n\n        // Get currently selected elements\n        const { elems: selElems } = opts\n\n        // Iterate through selected elements\n        for (const elem of selElems) {\n          // If the element has a connector start, handle it\n          if (elem && dataStorage.has(elem, 'c_start')) {\n            selectorManager.requestSelector(elem).showGrips(false)\n\n            // Show panel depending on selection state\n            showPanel(opts.selectedElement && !opts.multiselected)\n          } else {\n            // Hide panel if no connector start\n            showPanel(false)\n          }\n        }\n\n        // Update connectors based on selected elements\n        updateConnectors(svgCanvas.getSelectedElements())\n      },\n      elementChanged (opts) {\n        // Get the necessary data storage\n        const dataStorage = svgCanvas.getDataStorage()\n\n        // Get the first element from the options; exit early if it's null\n        let [elem] = opts.elems\n        if (!elem) return\n\n        // Reinitialize if it's the main SVG content\n        if (elem.tagName === 'svg' && elem.id === 'svgcontent') {\n          reset()\n        }\n\n        // Check for marker attributes and update offsets\n        const { markerStart, markerMid, markerEnd } = elem.attributes\n        if (markerStart || markerMid || markerEnd) {\n          curLine = elem\n          dataStorage.put(elem, 'start_off', Boolean(markerStart))\n          dataStorage.put(elem, 'end_off', Boolean(markerEnd))\n\n          // Convert lines to polyline if there's a mid-marker\n          if (elem.tagName === 'line' && markerMid) {\n            const { x1, x2, y1, y2, id } = elem.attributes\n\n            const midPt = `${(Number(x1.value) + Number(x2.value)) / 2},${\n              (Number(y1.value) + Number(y2.value)) / 2\n            }`\n            const pline = addSVGElementsFromJson({\n              element: 'polyline',\n              attr: {\n                points: `${x1.value},${y1.value} ${midPt} ${x2.value},${y2.value}`,\n                stroke: elem.getAttribute('stroke'),\n                'stroke-width': elem.getAttribute('stroke-width'),\n                'marker-mid': markerMid.value,\n                fill: 'none',\n                opacity: elem.getAttribute('opacity') || 1\n              }\n            })\n\n            elem.insertAdjacentElement('afterend', pline)\n            elem.remove()\n            svgCanvas.clearSelection()\n            pline.id = id.value\n            svgCanvas.addToSelection([pline])\n            elem = pline\n          }\n        }\n\n        // Update connectors based on the current element\n        if (elem?.id.startsWith('conn_')) {\n          const start = getElement(dataStorage.get(elem, 'c_start'))\n          updateConnectors([start])\n        } else {\n          updateConnectors(svgCanvas.getSelectedElements())\n        }\n      },\n      IDsUpdated (input) {\n        const remove = []\n        input.elems.forEach(function (elem) {\n          if ('se:connector' in elem.attr) {\n            elem.attr['se:connector'] = elem.attr['se:connector']\n              .split(' ')\n              .map(function (oldID) {\n                return input.changes[oldID]\n              })\n              .join(' ')\n\n            // Check validity - the field would be something like 'svg_21 svg_22', but\n            // if one end is missing, it would be 'svg_21' and therefore fail this test\n            if (!/. ./.test(elem.attr['se:connector'])) {\n              remove.push(elem.attr.id)\n            }\n          }\n        })\n        return { remove }\n      },\n      toolButtonStateUpdate (opts) {\n        const button = document.getElementById('tool_connect')\n        if (opts.nostroke && button.pressed === true) {\n          svgEditor.clickSelect()\n        }\n        button.disabled = opts.nostroke\n      }\n    }\n  }\n}\n","export default {\n  name: 'Connector',\n  langListTitle: 'Connect two objects',\n  langList: [\n    { id: 'mode_connect', title: 'Connect two objects' }\n  ],\n  buttons: [\n    {\n      title: 'Connect two objects'\n    }\n  ]\n}\n","export default {\n  name: 'Connecteur',\n  langListTitle: 'Connecter deux objets',\n  langList: [\n    { id: 'mode_connect', title: 'Connecter deux objets' }\n  ],\n  buttons: [\n    {\n      title: 'Connecter deux objets'\n    }\n  ]\n}\n","export default {\n  name: '连接器',\n  langListTitle: '连接两个对象',\n  langList: [\n    { id: 'mode_connect', title: '连接两个对象' }\n  ],\n  buttons: [\n    {\n      title: '连接两个对象'\n    }\n  ]\n}\n"],"names":["name","loadExtensionTranslation","async","svgEditor","translationModule","lang","configObj","pref","__variableDynamicImportRuntime0__","_error","console","warn","Promise","resolve","then","en$1","i18next","addResourceBundle","default","extConnector","init","S","this","svgCanvas","getElement","$id","$click","addSVGElementsFromJson","svgroot","selectorManager","seNs","getEditorNS","curLine","startElem","endElem","started","connections","originalGroupSelectedElements","groupSelectedElements","removeFromSelection","document","querySelectorAll","_len","arguments","length","args","Array","_key","apply","originalMoveSelectedElements","moveSelectedElements","_len2","_key2","cmd","updateConnectors","getSelectedElements","getBBintersect","x","y","bb","offset","width","height","midX","midY","lenX","lenY","ratio","Math","abs","getOffset","side","line","hasMarker","getAttribute","size","showPanel","on","connRules","createElement","setAttribute","getElementsByTagName","appendChild","textContent","style","display","setPoint","elem","pos","setMid","pts","points","pt","createSVGPoint","numberOfItems","replaceItem","ptStart","getItem","ptEnd","findConnectors","elems","undefined","dataStorage","getDataStorage","connectors","connector","addThis","parts","i","entries","part","get","getElementById","attributes","value","split","put","id","getStrokedBBox","push","cElem","parents","getParents","parentNode","el","includes","is_start","start_x","start_y","remove","conn","isStart","startX","startY","pre","altPre","bb2","pt2","reset","getSvgContent","forEach","element","getAttributeNS","connData","sbb","ebb","t","callback","buttonTemplate","title","innerHTML","append","content","cloneNode","leftPanel","updateLeftPanel","setMode","mouseDown","opts","svgContent","event","e","mode","getMode","curConfig","initStroke","mouseTarget","target","fo","getClosest","attr","getNextId","stroke","color","stroke_width","fill","opacity","selectedElements","mouseMove","getZoom","mouse_x","mouse_y","mouseUp","isInSvgContent","keep","startId","endId","connStr","altStr","from","filter","setAttributeNS","addToSelection","moveToBottomSelectedElement","requestSelector","showGrips","selectedChanged","selElems","has","selectedElement","multiselected","elementChanged","tagName","markerStart","markerMid","markerEnd","Boolean","x1","x2","y1","y2","midPt","Number","pline","insertAdjacentElement","clearSelection","startsWith","start","IDsUpdated","input","map","oldID","changes","join","test","toolButtonStateUpdate","button","nostroke","pressed","clickSelect","disabled","langListTitle","langList","buttons"],"mappings":"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"}